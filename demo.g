LoadPackage("scscp");
SetInfoLevel(InfoSCSCP,4);
Read("gap/mitm.g");
 
#############################################################################
#
# Check that we are able to parse and evaluate OpenMath code with symbols from
# the content dictionary 'scscp_transient_mitm'
#
stream := InputTextFile(Filename(DirectoryCurrent(),"tst/mitm.tst"));
OMGetObject(stream);
OMGetObject(stream);
CloseStream(stream);

#############################################################################
#
# Simple ping-pong examples
#
EvaluateBySCSCP("MitM_OMstring",[(1,2)],"localhost",26133);
EvaluateBySCSCP("MitM_OMobj",[(1,2)],"localhost",26133);

EvaluateBySCSCP("MitM_OMstring",[Group((1,2))],"localhost",26133);
EvaluateBySCSCP("MitM_OMobj",[Group((1,2))],"localhost",26133);

#############################################################################
#
# Ping-pong example with conversion on both client and server sides
#
EvaluateBySCSCP("MitM_OMstring",[OMPlainString(MitM_OM(SymmetricGroup(3)))],"localhost",26133);
EvaluateBySCSCP("MitM_OMobj",[OMPlainString(MitM_OM(SymmetricGroup(3)))],"localhost",26133);

#############################################################################
#
# Calling generic procedure to evaluate given OpenMath code
#
EvaluateBySCSCP("EvaluateOpenMath",[OMPlainString(MitM_OM(SymmetricGroup(3)))],"localhost",26133);

#############################################################################
#
# Working with remote objects (1)
#

# Create remote group and get back the reference
r:=EvaluateBySCSCP("EvaluateOpenMath",[OMPlainString(MitM_OM(Group((1,2),(1,2,4))))],"localhost",26133:output:="cookie");
g:=r.object;

# Construct OpenMath code to calculate the order of the remote group
rpc:=OMPlainString( Concatenation("<OMA><OMS cd=\"scscp_transient_mitm\" name=\"Size\"/>", OMString(g:noomobj), "</OMA>") );

# Evaluate the constructed OpenMath code
EvaluateBySCSCP("EvaluateOpenMath",[rpc],"localhost",26133);

#############################################################################
#
# Working with remote objects (2)
#
# Given two matrices, find the order of the group that they generate
# (useful in the scenario when the client's system works with matrices
# but does not work with groups).

m1:= # PermutationMat((2,7,3,8,4,9,5,10,6,1),10);
[ [ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ], 
  [ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 ], 
  [ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 ], 
  [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 ], 
  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 ], 
  [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], 
  [ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 ], 
  [ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 ], 
  [ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 ], 
  [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 ] ];

m2 := # PermutationMat((2,1,3,4,5,6,7,8,9,10),10);
[ [ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 ], 
  [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], 
  [ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 ], 
  [ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 ], 
  [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 ], 
  [ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 ], 
  [ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 ], 
  [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 ], 
  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 ], 
  [ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ] ];

# Assemble and execute procedure call to create a remote group 
# generated by these two matrices
rpc:=OMPlainString( Concatenation("<OMA><OMS cd=\"scscp_transient_mitm\" name=\"Group\"/>", OMString([m1,m2]:noomobj), "</OMA>") );
r:=EvaluateBySCSCP("EvaluateOpenMath",[rpc],"localhost",26133 : output:="cookie");
g:=r.object;

# Assemble and execute procedure call to calculate the order of this group
# Construct OpenMath code to calculate the order of the remote group
rpc:=OMPlainString( Concatenation("<OMA><OMS cd=\"scscp_transient_mitm\" name=\"Size\"/>", OMString(g:noomobj), "</OMA>") );
EvaluateBySCSCP("EvaluateOpenMath",[rpc],"localhost",26133);




